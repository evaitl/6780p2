Introduction
============

The code here is a solution to CSCI 6780 [Programming Project
2](./docs/Programming-Project2.pdf). This project builds on
[Programming Project 1](./docs/Programming-Project1.pdf).

While this file is human readable, it is best to view it as a
processed markdown file on the github site
[here](https://github.com/evaitl/6780p2).


Design Notes
============


## Protocol


For Project 1 we pretty much followed the FTP protocol, with some
minor exceptions.  The requirements for project 2 break any
possibility with interoperation with FTP, so I'll feel free with
modifying the protocol.

Project 2 has actions running in multiple threads and can return
responses out of order. In order to match commands and responses,
every command will start with an integer CommandId.  The corresponding
responses start with the same CommandId.

Commands accepted on command socket are: MKD, RMD, CDUP, CWD, DELE,
PWD, LIST, RETR, STOR.

Format for a command is:

    CommandID Command Arguments

Every command is terminated with a new line (\n).

Responses are all preceded by the CommandId and terminated with a newline: 

   CommandId ResponseCode  Other stuff

We aren't really using the response codes, so just use the numbers
100, 200, and 500. 100 is the intermediate response for LIST, RETR,
and STOR. 200 is a positive command completion. 500 is a negative
command completion.

On the terminate socket, we just send a CommandId terminated with a
newline. There is no response on the terminate socket. 

LIST, RETR, STOR:

LIST has no arguments. RETR and STOR have a filename argument.
Response is normally a commandId, 100, followed by an the transferID,
IP address and port:

	  75 100 22,127.0.0.1,5467

The specification requires a transfer ID to be generated by the
server, so I can't reuse the commandID for the terminate commands. 

If something goes wrong however (file can't be opened, socket failure,
etcetera) the response code for a RETR, STOR, or LIST would be a 500.

The transfer ID, IP address and port are seperated with commas in
case the IP address is an IPv6 address. For IPv6 a response may look
like:

          7 100 6,2001:0db8:85a3:0000:0000:8a2e:0370:7334,5467

If (for instance) the file can't be opened, we will get a 500 response:

   82 500 Can't open file. 

On completion we will get a 200 or a 500 response.

   14 200 Xfer OK

Or

   25 500 Xfer terminated. 


## Client design notes:

This project seems about threads, so I'm sure we aren't allowed to use
a reactive system with callbacks (poll/epoll/select). 

We aren't allowed to use thread-safe data structures. I'm assuming
that means that we can't use `java.util.concurrent.Concurrent\*`, but
we can still use the `synchronized` keyword and the monitors built
into every Object.  It should be pretty easy enough to re-create
whatever data structure we need.

Because some commands responses can happen out of order, we need one
thread on the user interface (ClientMain), and one on the
commandSocket ClientCommandHandler.  For get/put (RETR/STOR), we may
need to kick off threads on temporary data sockets. The terminate
socket is just written to and we will assume that the buffer doesn't
fill up enough to block. So:

<pre>
   ClientMain implements Runnable   
      Keeps list of backgrounded get/put tasks.  List is
      searched/updated in synchronized methods.
      Owns user interface socket.
      commandResponse(int id, int code, String resp)      
      synchronized void transferComplete(int id);
      synchronized void transferStart(DataXfer bg);
      synchronized boolean currentXfer(int id);
      
   CommandHandler implements Runnable, Closeable
       Owns commandSocket
       synchronized println();

   interface  DataXfer implements Closeable, Runnable
        int  getId()

   class RetrData implements DataXfer

   class StorData implements DataXfer

   class ListData implements DataXfer

</pre>

The DataXfer classes call `ClientMain::transferComplete()` when their
transfers are done.

If a get/put/list is done without the '&', ClientMain sends the
command, creates the DataXfer class, and calls `DataXfer.run()`
directly. If a get/put is done with the '&', ClientMain uses
`Thread.start()` to kick off the DataXfer `run()` method.

On a terminate command, ClientMain checks the outstanding command
list. If found sends the teminate message. If this was a get, then
`java.io.file.Files.deleteIfExists()` the target file.  If commandId
not in outstanding command list, just tell the user.


## Server side notes:

There are several sockets to keep track of:

* serverSocket - one per process
* terminateSocket - one per process
* commandSocket - one per client. Returned by serverSocket.accept()
* dataServerSocket - Created, accept() once, and closed per RETR/STOR/LIST
* dataXferSocket - used once per RETR/STOR/LIST. Returned from
  dataServerSocket.accept.

We aren't supposed to do reactive programming here, so threads it
is. The classes:

    ServerMain
       Kicks off a TerminateHandler thread
       Owns serverSocket. Does serverSocket.accept(), kicks off
       new CommandHandlers.
       Keeps synchronized list of CommandHandlers.
       void terminateXfer(int id) -- forwards terminate command
          to all current CommandHandlers      

    TerminateHandler implements Runnable
       Creates/owns terminateSocket.
       Calls ServerMain.terminateXfer(id) on a terminate command. 


    CommandHandler implements Runnable
       Owns commandSocket.
       Keeps synchronized list of backgrounded Xfers for this client.
       synchronized void terminateXfer(int id);
       synchronized void xferComplete(int id);
       synchronized void addBg(DataXfer bg);

    interface DataXfer extends Runnable, Closeable
       int getId()

    ListXfer implements DataXfer

    RetrXfer implements DataXfer

    StorXfer implements DataXfer
    
The Xfer classes call CommandHandler::xferComplete() when done.

If a CommandSocket is closed, the CommandHandler should close() all
associated ServerDataXfer objects before returning from run().


Sequence Diagrams:
==================

A couple of sequence diagrams to clarify operation and protocol:

![Terminated RETR](docs/retr_term.png)


Questions:
==========




Disclaimer
==========

This project was done in its entirety by Eric Vaitl and Ankita
Joshi. We hereby state that we have not received unauthorized help of
any form.

